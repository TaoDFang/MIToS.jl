<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Information · MIToS</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MIToS</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../Installation/">Installation</a></li><li><a class="tocitem" href="../Example/">Example</a></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../MSA/">MSA</a></li><li class="is-active"><a class="tocitem" href>Information</a><ul class="internal"><li><a class="tocitem" href="#Features"><span>Features</span></a></li><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Counting-residues"><span>Counting residues</span></a></li><li><a class="tocitem" href="#Low-count-corrections"><span>Low count corrections</span></a></li><li><a class="tocitem" href="#Correction-for-data-redundancy-in-a-MSA"><span>Correction for data redundancy in a MSA</span></a></li><li><a class="tocitem" href="#Estimating-information-measures-on-an-MSA"><span>Estimating information measures on an MSA</span></a></li><li><a class="tocitem" href="#Corrected-Mutual-Information"><span>Corrected Mutual Information</span></a></li><li><a class="tocitem" href="#Visualize-Mutual-Information"><span>Visualize Mutual Information</span></a></li></ul></li><li><a class="tocitem" href="../SIFTS/">SIFTS</a></li><li><a class="tocitem" href="../PDB/">PDB</a></li><li><a class="tocitem" href="../Pfam/">Pfam</a></li></ul></li><li><span class="tocitem">Cookbook</span><ul><li><a class="tocitem" href="../01_Change_B_factors/">Change B-factors</a></li><li><a class="tocitem" href="../02_Linking_structural_and_evolutionary_information/">Linking structural and evolutionary information</a></li><li><a class="tocitem" href="../03_RMSF/">Root Mean Squared Fluctuation (RMSF)</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../MSA_API/">MSA</a></li><li><a class="tocitem" href="../Information_API/">Information</a></li><li><a class="tocitem" href="../SIFTS_API/">SIFTS</a></li><li><a class="tocitem" href="../PDB_API/">PDB</a></li><li><a class="tocitem" href="../Pfam_API/">Pfam</a></li><li><a class="tocitem" href="../Utils_API/">Utils</a></li></ul></li><li><a class="tocitem" href="../Scripts/">Scripts</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Information</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Information</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/diegozea/MIToS.jl/blob/master/docs/src/Information.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Module-Information"><a class="docs-heading-anchor" href="#Module-Information">Information</a><a id="Module-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Module-Information" title="Permalink"></a></h1><p>The <code>Information</code> module of MIToS defines types and functions useful to calculate information measures (e.g. <em>Mutual Information</em> (MI) and <em>Entropy</em>) over a Multiple Sequence Alignment (MSA). This module was designed to count <code>Residue</code>s (defined in the <code>MSA</code> module) in special contingency tables (as fast as possible) and to derive probabilities from these counts. Also, includes methods for applying corrections to those tables, e.g. pseudocounts and pseudo frequencies. Finally, <code>Information</code> allows to use these probabilities and counts to estimate information measures and other frequency based values.  </p><pre><code class="language-julia">using MIToS.Information # to load the Information module</code></pre><h2 id="Features"><a class="docs-heading-anchor" href="#Features">Features</a><a id="Features-1"></a><a class="docs-heading-anchor-permalink" href="#Features" title="Permalink"></a></h2><ul><li>Estimate multi dimensional frequencies and probability tables from sequences, MSAs, etc...</li><li>Correction for small number of observations</li><li>Correction for data redundancy on a MSA</li><li>Estimate information measures</li><li>Calculate corrected mutual information between residues  </li></ul><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Module-Information">Information</a></li><ul><li><a href="#Features">Features</a></li><li><a href="#Contents">Contents</a></li><li><a href="#Counting-residues">Counting residues</a></li><ul><ul><li><a href="#Example:-Plotting-the-probabilities-of-each-residue-in-a-sequence">Example: Plotting the probabilities of each residue in a sequence</a></li></ul></ul><li><a href="#Low-count-corrections">Low count corrections</a></li><li><a href="#Correction-for-data-redundancy-in-a-MSA">Correction for data redundancy in a MSA</a></li><li><a href="#Estimating-information-measures-on-an-MSA">Estimating information measures on an MSA</a></li><ul><ul><li><a href="#Example:-Estimating-*H(X)*-and-*H(X,-Y)*-over-an-MSA">Example: Estimating <em>H(X)</em> and <em>H(X, Y)</em> over an MSA</a></li></ul></ul><li><a href="#Corrected-Mutual-Information">Corrected Mutual Information</a></li><ul><ul><li><a href="#Example:-Estimating-corrected-MI-from-an-MSA">Example: Estimating corrected MI from an MSA</a></li></ul></ul><li><a href="#Visualize-Mutual-Information">Visualize Mutual Information</a></li></ul></ul><h2 id="Counting-residues"><a class="docs-heading-anchor" href="#Counting-residues">Counting residues</a><a id="Counting-residues-1"></a><a class="docs-heading-anchor-permalink" href="#Counting-residues" title="Permalink"></a></h2><p>MIToS Information module defines a multidimensional <code>ContingencyTable</code> type and two types wrapping it, <code>Counts</code> and <code>Probabilities</code>, to store occurrences or probabilities. The <code>ContingencyTable</code> type stores the contingency matrix, its marginal values and total. These types are parametric, taking three ordered parameters:</p><ul><li><code>T</code> : The type used for storing the counts or probabilities, e.g. <code>Float64</code>. It&#39;s</li></ul><p>possible to use <code>BigFloat</code> if more precision it&#39;s needed.</p><ul><li><code>N</code> : It&#39;s the dimension of the table and should be an <code>Int</code>.</li><li><code>A</code> : This should be a type, subtype of <code>ResidueAlphabet</code>, i.e.: <code>UngappedAlphabet</code>,</li></ul><p><code>GappedAlphabet</code> or <code>ReducedAlphabet</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>ContingencyTable</code> can be used for storing probabilities or counts. The wrapper types <code>Probabilities</code> and <code>Counts</code> are mainly intended to dispatch in methods that need to know if the matrix has probabilities or counts, e.g. <code>entropy</code>. In general, the use of <code>ContingencyTable</code> is recommended over the use of <code>Probabilities</code> and <code>Counts</code>.</p></div></div><p>In this way, a matrix for storing pairwise probabilities of residues (without gaps) can be initialized using:  </p><pre><code class="language-julia">using MIToS.Information

Pij = ContingencyTable(Float64, Val{2}, UngappedAlphabet())</code></pre><pre class="documenter-example-output">MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.UngappedAlphabet} : 

table : 20×20 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │   A    R    N    D    C    Q  …    P    S    T    W    Y    V
──────────────┼──────────────────────────────────────────────────────────────
A             │ 0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0
R             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
N             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
D             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
C             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
Q             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
E             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
G             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
H             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
⋮                 ⋮    ⋮    ⋮    ⋮    ⋮    ⋮  ⋱    ⋮    ⋮    ⋮    ⋮    ⋮    ⋮
K             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
M             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
F             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
P             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
S             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
T             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
W             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
Y             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
V             │ 0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0

marginals : 20×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
A             │   0.0    0.0
R             │   0.0    0.0
N             │   0.0    0.0
D             │   0.0    0.0
C             │   0.0    0.0
Q             │   0.0    0.0
E             │   0.0    0.0
G             │   0.0    0.0
H             │   0.0    0.0
⋮                   ⋮      ⋮
K             │   0.0    0.0
M             │   0.0    0.0
F             │   0.0    0.0
P             │   0.0    0.0
S             │   0.0    0.0
T             │   0.0    0.0
W             │   0.0    0.0
Y             │   0.0    0.0
V             │   0.0    0.0

total : 0.0</pre><p><strong>[High level interface]</strong> It is possible to use the functions <code>count</code> and <code>probabilities</code> to easily calculate the frequencies of sequences or columns of a MSA, where the number of sequences/columns determine the dimension of the resulting table.  </p><pre><code class="language-julia">using MIToS.Information
using MIToS.MSA # to use res&quot;...&quot; to create Vector{Residue}

column_i = res&quot;AARANHDDRDC-&quot;
column_j = res&quot;-ARRNHADRAVY&quot;
#   Nij[R,R] =   1     1   = 2

Nij = count(column_i, column_j)</code></pre><pre class="documenter-example-output">MIToS.Information.Counts{Float64,2,MIToS.MSA.UngappedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.UngappedAlphabet} : 

table : 20×20 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │   A    R    N    D    C    Q  …    P    S    T    W    Y    V
──────────────┼──────────────────────────────────────────────────────────────
A             │ 1.0  1.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0
R             │ 0.0  2.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
N             │ 0.0  0.0  1.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
D             │ 2.0  0.0  0.0  1.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
C             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  1.0
Q             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
E             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
G             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
H             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
⋮                 ⋮    ⋮    ⋮    ⋮    ⋮    ⋮  ⋱    ⋮    ⋮    ⋮    ⋮    ⋮    ⋮
K             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
M             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
F             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
P             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
S             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
T             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
W             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
Y             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
V             │ 0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0

marginals : 20×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
A             │   2.0    3.0
R             │   2.0    3.0
N             │   1.0    1.0
D             │   3.0    1.0
C             │   1.0    0.0
Q             │   0.0    0.0
E             │   0.0    0.0
G             │   0.0    0.0
H             │   1.0    1.0
⋮                   ⋮      ⋮
K             │   0.0    0.0
M             │   0.0    0.0
F             │   0.0    0.0
P             │   0.0    0.0
S             │   0.0    0.0
T             │   0.0    0.0
W             │   0.0    0.0
Y             │   0.0    0.0
V             │   0.0    1.0

total : 10.0</pre><p>You can use <code>sum</code> to get the stored total:  </p><pre><code class="language-julia">sum(Nij) # There are 12 Residues, but 2 are gaps</code></pre><pre class="documenter-example-output">10.0</pre><p>Contingency tables can be indexed using <code>Int</code> or <code>Residue</code>s:  </p><pre><code class="language-julia">Nij[2, 2] # Use Int to index the table</code></pre><pre class="documenter-example-output">2.0</pre><pre><code class="language-julia">Nij[Residue(&#39;R&#39;), Residue(&#39;R&#39;)] # Use Residue to index the table</code></pre><pre class="documenter-example-output">2.0</pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The number makes reference to the specific index in the table e.g <code>[2,2]</code> references the second row and the second column. The use of the number used to encode the residue to index the table is dangerous. The equivalent index number of a residue depends on the used alphabet and <code>Int(Residue(&#39;X&#39;))</code> will be always out of bounds.  </p></div></div><p>Indexing with <code>Residue</code>s works as expected. It uses the alphabet of the contingency table to find the index of the <code>Residue</code>.</p><pre><code class="language-julia">using MIToS.Information
using MIToS.MSA

alphabet = ReducedAlphabet(&quot;(AILMV)(NQST)(RHK)(DE)(FWY)CGP&quot;)

column_i = res&quot;AARANHDDRDC-&quot;
column_j = res&quot;-ARRNHADRAVY&quot;
#   Fij[R,R] =   1  1  1   = 3 # RHK

Fij = count(column_i, column_j, alphabet=alphabet)</code></pre><pre class="documenter-example-output">MIToS.Information.Counts{Float64,2,MIToS.MSA.ReducedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} : 

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │   1.0    0.0    1.0    0.0    0.0    0.0    0.0    0.0
NQST          │   0.0    1.0    0.0    0.0    0.0    0.0    0.0    0.0
RHK           │   0.0    0.0    3.0    0.0    0.0    0.0    0.0    0.0
DE            │   2.0    0.0    0.0    1.0    0.0    0.0    0.0    0.0
FWY           │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
C             │   1.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
G             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
P             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │   2.0    4.0
NQST          │   1.0    1.0
RHK           │   3.0    4.0
DE            │   3.0    1.0
FWY           │   0.0    0.0
C             │   1.0    0.0
G             │   0.0    0.0
P             │   0.0    0.0

total : 10.0</pre><pre><code class="language-julia">Fij[Residue(&#39;R&#39;), Residue(&#39;R&#39;)] # Use Residue to index the table</code></pre><pre class="documenter-example-output">3.0</pre><p>The function <code>getcontingencytable</code> allows to access the wrapped <code>ContingencyTable</code> in a <code>Counts</code> object. You can use it, in combination with <code>normalize</code> to get a contingency table of probabilities. The result can be wrapped inside a <code>Probabilities</code> object:  </p><pre><code class="language-julia">Probabilities(normalize(getcontingencytable(Fij)))</code></pre><pre class="documenter-example-output">MIToS.Information.Probabilities{Float64,2,MIToS.MSA.ReducedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} : 

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │   0.1    0.0    0.1    0.0    0.0    0.0    0.0    0.0
NQST          │   0.0    0.1    0.0    0.0    0.0    0.0    0.0    0.0
RHK           │   0.0    0.0    0.3    0.0    0.0    0.0    0.0    0.0
DE            │   0.2    0.0    0.0    0.1    0.0    0.0    0.0    0.0
FWY           │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
C             │   0.1    0.0    0.0    0.0    0.0    0.0    0.0    0.0
G             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
P             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │   0.2    0.4
NQST          │   0.1    0.1
RHK           │   0.3    0.4
DE            │   0.3    0.1
FWY           │   0.0    0.0
C             │   0.1    0.0
G             │   0.0    0.0
P             │   0.0    0.0

total : 1.0000000000000002</pre><h4 id="Example:-Plotting-the-probabilities-of-each-residue-in-a-sequence"><a class="docs-heading-anchor" href="#Example:-Plotting-the-probabilities-of-each-residue-in-a-sequence">Example: Plotting the probabilities of each residue in a sequence</a><a id="Example:-Plotting-the-probabilities-of-each-residue-in-a-sequence-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Plotting-the-probabilities-of-each-residue-in-a-sequence" title="Permalink"></a></h4><p>Similar to the <code>count</code> function, the <code>probabilities</code> function can take at least one sequence (vector of residues) and returns the probabilities of each residue. Optionally, the keyword argument <code>alphabet</code> could be used to count some residues in the same cell of the table.  </p><pre><code class="language-julia">probabilities(res&quot;AARANHDDRDC&quot;, alphabet=alphabet)</code></pre><pre class="documenter-example-output">MIToS.Information.Probabilities{Float64,1,MIToS.MSA.ReducedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,1,MIToS.MSA.ReducedAlphabet} : 

table : 8-element Named Array{Float64,1}
Dim_1  │ 
───────┼──────────
AILMV  │  0.272727
NQST   │ 0.0909091
RHK    │  0.272727
DE     │  0.272727
FWY    │       0.0
C      │ 0.0909091
G      │       0.0
P      │       0.0

total : 1.0</pre><p>Here, we are going to use the <code>probabilities</code> function to get the residue probabilities of a particular sequence from <em>UniProt</em>.</p><p>use the <code>getsequence</code> function, from the <code>MSA</code> module, to get the sequence from a <code>FASTA</code> downloaded from UniProt.  </p><pre><code class="language-julia-repl">julia&gt; using MIToS.Information # to use the probabilities function

julia&gt; using MIToS.MSA # to use getsequence on the one sequence FASTA (canonical) from UniProt

julia&gt; seq = read(&quot;http://www.uniprot.org/uniprot/P29374.fasta&quot;, FASTA) # Small hack: read the single sequence as a MSA
AnnotatedMultipleSequenceAlignment with 0 annotations : 1×1257 Named Array{MIToS.MSA.Residue,2}
                                                                                                         Seq ╲ Col │   …
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────┼──────
sp|P29374|ARI4A_HUMAN AT-rich interactive domain-containing protein 4A OS=Homo sapiens OX=9606 GN=ARID4A PE=1 SV=3 │   …

julia&gt; probabilities(seq[1,:]) # Select the single sequence and calculate the probabilities
MIToS.Information.Probabilities{Float64,1,MIToS.MSA.UngappedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,1,MIToS.MSA.UngappedAlphabet} :

table : 20-element Named Array{Float64,1}
Dim_1  │
───────┼───────────
A      │   0.043755
R      │  0.0517104
N      │  0.0469372
D      │  0.0755768
C      │  0.0135243
Q      │   0.035004
E      │   0.134447
G      │   0.043755
H      │  0.0143198
⋮                 ⋮
K      │   0.109785
M      │  0.0159109
F      │  0.0190931
P      │  0.0445505
S      │   0.100239
T      │  0.0493238
W      │ 0.00636436
Y      │  0.0198886
V      │  0.0517104

total : 1.0</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In the previous example, using <code>getsequence(seq,1)</code> instead of <code>seq[1,:]</code> will return the sequence as a matrix with a single column to keep information for both dimensions. To use <code>probabilities</code> (or <code>count</code>) you can make use of the Julia&#39;s <code>vec</code> function to transform the matrix to a vector, e.g.: <code>probabilities(vec(getsequence(seq,1)))</code>.</p></div></div><pre><code class="language-julia">using Plots # We choose Plots because it&#39;s intuitive, concise and backend independent
gr(size=(600,300))</code></pre><pre class="documenter-example-output">Plots.GRBackend()</pre><p>You can plot together with the probabilities of each residue in a given sequence, the probabilities of each residue estimated with the BLOSUM62 substitution matrix. That matrix is exported as a constant by the <code>Information</code> module as <code>BLOSUM62_Pi</code>.  </p><pre><code class="language-julia">bar(
    1:20,
    [ frequencies  BLOSUM62_Pi ],
    lab = [ &quot;Sequence&quot;  &quot;BLOSUM62&quot;   ],
    alpha=0.5
    )</code></pre><p><img src="../inf_plotfreq.png" alt/>  </p><h2 id="Low-count-corrections"><a class="docs-heading-anchor" href="#Low-count-corrections">Low count corrections</a><a id="Low-count-corrections-1"></a><a class="docs-heading-anchor-permalink" href="#Low-count-corrections" title="Permalink"></a></h2><p>Low number of observations can lead to sparse contingency tables, that lead to wrong probability estimations. It is shown in <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2672635/"><em>Buslje et. al. 2009</em><img src="../assets/external-link.png" alt/></a> that low-count corrections, can lead to improvements in the contact prediction capabilities of the Mutual Information. The Information module has available two low-count corrections:  </p><ol><li><a href="https://en.wikipedia.org/wiki/Additive_smoothing">Additive Smoothing<img src="../assets/external-link.png" alt/></a>; the constant value pseudocount described in <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2672635/"><em>Buslje et. al. 2009</em><img src="../assets/external-link.png" alt/></a>.  </li><li>BLOSUM62 based pseudo frequencies of residues pairs, similar to <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC146917/"><em>Altschul et. al. 1997</em><img src="../assets/external-link.png" alt/></a>.  </li></ol><pre><code class="language-julia">using MIToS.MSA

msa = read(&quot;http://pfam.xfam.org/family/PF09776/alignment/full&quot;, Stockholm)

filtercolumns!(msa, columngapfraction(msa) .&lt; 0.5) # delete columns with 50% gaps or more

column_i = msa[:,1]
column_j = msa[:,2]</code></pre><pre class="documenter-example-output">325-element Named Array{MIToS.MSA.Residue,1}
Seq                        │ 
───────────────────────────┼──
A0A2K6AF64_MANLE/10-125    │ L
G1RVK4_NOMLE/46-161        │ F
A0A0V0S2G9_9BILA/731-840   │ -
A0A1V4KDS6_PATFA/159-270   │ L
M4A0G1_XIPMA/29-139        │ -
A0A1I8N4P6_MUSDO/6-107     │ -
A0A3Q0KLM0_SCHMA/10-112    │ -
A0A3S0ZHC3_ELYCH/11-117    │ -
E0VEI6_PEDHC/4-112         │ -
⋮                            ⋮
A0A2Y9IJF3_ENHLU/10-125    │ H
H3DW02_PRIPA/2-115         │ I
A0A2I3GIP3_NOMLE/10-125    │ F
A0A3B3RWX1_9TELE/15-129    │ A
A0A090MXF3_STRRB/2-104     │ -
A0A3B1JKX3_ASTMX/16-130    │ A
G3WPK1_SARHA/11-126        │ L
M3XPJ7_MUSPF/10-125        │ H
A0A2K6LYH7_RHIBE/10-125    │ L</pre><p>If you have a preallocated <code>ContingencyTable</code> you can use <code>count!</code> to fill it, this prevent to create a new table as <code>count</code> do. However, you should note that <code>count!</code> <strong>adds the new counts to the pre existing values</strong>, so in this case, we want to start with a table initialized with zeros.  </p><pre><code class="language-julia">using MIToS.Information

const alphabet = ReducedAlphabet(&quot;(AILMV)(NQST)(RHK)(DE)(FWY)CGP&quot;)

Nij = ContingencyTable(Float64, Val{2}, alphabet)</code></pre><pre class="documenter-example-output">MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} : 

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
NQST          │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
RHK           │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
DE            │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
FWY           │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
C             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
G             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
P             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │   0.0    0.0
NQST          │   0.0    0.0
RHK           │   0.0    0.0
DE            │   0.0    0.0
FWY           │   0.0    0.0
C             │   0.0    0.0
G             │   0.0    0.0
P             │   0.0    0.0

total : 0.0</pre><pre><code class="language-julia">#      table  weights         pseudocount      sequences...
count!(Nij,   NoClustering(), NoPseudocount(), column_i, column_j)</code></pre><pre class="documenter-example-output">MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} : 

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │  53.0    3.0    9.0    0.0    2.0    1.0    0.0    6.0
NQST          │  31.0   10.0   11.0    0.0    0.0    0.0    2.0    5.0
RHK           │  10.0    2.0    0.0    0.0    0.0    0.0    0.0    5.0
DE            │   0.0    5.0    2.0    0.0    0.0    0.0    0.0    0.0
FWY           │   0.0    1.0    0.0    0.0    0.0    0.0    0.0    0.0
C             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
G             │   1.0    1.0    0.0    0.0    0.0    0.0    0.0    0.0
P             │   1.0    0.0    0.0    0.0    0.0    1.0    0.0    3.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │  74.0   96.0
NQST          │  59.0   22.0
RHK           │  17.0   22.0
DE            │   7.0    0.0
FWY           │   1.0    2.0
C             │   0.0    2.0
G             │   2.0    2.0
P             │   5.0   19.0

total : 165.0</pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You can use <code>NoClustering()</code> in places where clustering weights are required to not use weights. Also, <code>NoPseudocount()</code> in places where pseudocount values are required to not use pseudocounts.</p></div></div><p>In cases like the above, where there are few observations, it is possible to apply a constant pseudocount to the counting table.  This module defines the type <code>AdditiveSmoothing</code> and the correspond <code>fill!</code> and  <code>apply_pseudocount!</code> methods to efficiently add or fill with a constant value each element of the table.</p><pre><code class="language-julia">apply_pseudocount!(Nij, AdditiveSmoothing(1.0))</code></pre><pre class="documenter-example-output">MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} : 

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │  54.0    4.0   10.0    1.0    3.0    2.0    1.0    7.0
NQST          │  32.0   11.0   12.0    1.0    1.0    1.0    3.0    6.0
RHK           │  11.0    3.0    1.0    1.0    1.0    1.0    1.0    6.0
DE            │   1.0    6.0    3.0    1.0    1.0    1.0    1.0    1.0
FWY           │   1.0    2.0    1.0    1.0    1.0    1.0    1.0    1.0
C             │   1.0    1.0    1.0    1.0    1.0    1.0    1.0    1.0
G             │   2.0    2.0    1.0    1.0    1.0    1.0    1.0    1.0
P             │   2.0    1.0    1.0    1.0    1.0    2.0    1.0    4.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │  82.0  104.0
NQST          │  67.0   30.0
RHK           │  25.0   30.0
DE            │  15.0    8.0
FWY           │   9.0   10.0
C             │   8.0   10.0
G             │  10.0   10.0
P             │  13.0   27.0

total : 229.0</pre><p><strong>[High level interface.]</strong> The <code>count</code> function has a <code>pseudocounts</code> keyword argument that can take a <code>AdditiveSmoothing</code> value to easily calculate occurrences with pseudocounts. Also the alphabet keyword argument can be used to chage the default alphabet (i.e. )</p><pre><code class="language-julia">count(column_i, column_j, pseudocounts=AdditiveSmoothing(1.0), alphabet=alphabet)</code></pre><pre class="documenter-example-output">MIToS.Information.Counts{Float64,2,MIToS.MSA.ReducedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} : 

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │  54.0    4.0   10.0    1.0    3.0    2.0    1.0    7.0
NQST          │  32.0   11.0   12.0    1.0    1.0    1.0    3.0    6.0
RHK           │  11.0    3.0    1.0    1.0    1.0    1.0    1.0    6.0
DE            │   1.0    6.0    3.0    1.0    1.0    1.0    1.0    1.0
FWY           │   1.0    2.0    1.0    1.0    1.0    1.0    1.0    1.0
C             │   1.0    1.0    1.0    1.0    1.0    1.0    1.0    1.0
G             │   2.0    2.0    1.0    1.0    1.0    1.0    1.0    1.0
P             │   2.0    1.0    1.0    1.0    1.0    2.0    1.0    4.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │  82.0  104.0
NQST          │  67.0   30.0
RHK           │  25.0   30.0
DE            │  15.0    8.0
FWY           │   9.0   10.0
C             │   8.0   10.0
G             │  10.0   10.0
P             │  13.0   27.0

total : 229.0</pre><p>To use the conditional probability matrix <code>BLOSUM62_Pij</code> in the calculation of pseudo frequencies <span>$G$</span> for the pair of residues <span>$a$</span>, <span>$b$</span>, it should be calculated first the real frequencies/probabilities <span>$p_{a,b}$</span>. The observed probabilities are then used to estimate the pseudo frequencies.  </p><div>\[G_{ab} = \sum_{cd}  p_{cd} \cdot BLOSUM62( a | c ) \cdot BLOSUM62( b | d )\]</div><p>Finally, the probability <span>$P$</span> of each pair of residues <span>$a$</span>, <span>$b$</span> between the columns <span>$i$</span>, <span>$j$</span> is the weighted mean between the observed frequency <span>$p$</span> and BLOSUM62-based pseudo frequency <span>$G$</span>, where α is generally the number of clusters or the number of sequences of the MSA and β is an empiric weight value. β was determined to be close to <code>8.512</code>.  </p><div>\[P_{ab} = \frac{\alpha \cdot p_{ab} + \beta \cdot G_{ab} }{\alpha + \beta}\]</div><p>This could be easily achieved using the <code>pseudofrequencies</code> keyword argument of the <code>probabilities</code> function. That argument can take a <code>BLOSUM_Pseudofrequencies</code> object that is created with α and β as first and second argument, respectively.</p><pre><code class="language-julia">Pij = probabilities(column_i, column_j, pseudofrequencies=BLOSUM_Pseudofrequencies(nsequences(msa), 8.512))</code></pre><pre class="documenter-example-output">MIToS.Information.Probabilities{Float64,2,MIToS.MSA.UngappedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.UngappedAlphabet} : 

table : 20×20 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │           A            R  …            Y            V
──────────────┼──────────────────────────────────────────────────────
A             │   0.0298271    0.0119825  …   8.12799e-5    0.0357753
R             │ 0.000148923   6.34139e-5      2.93009e-5   0.00603478
N             │  9.21195e-5   4.69507e-5       1.8159e-5    7.1241e-5
D             │  9.80851e-5   4.94086e-5      1.92655e-5   7.43832e-5
C             │  3.66742e-5     2.294e-5      8.87209e-6   3.61161e-5
Q             │   0.0888057   6.08174e-5      2.72942e-5   0.00601557
E             │ 0.000175098   7.72929e-5       3.0578e-5  0.000114401
G             │  0.00605951    7.4065e-5      3.21575e-5  0.000127606
H             │   0.0118925   2.56176e-5      1.10077e-5   4.36908e-5
⋮                         ⋮            ⋮  ⋱            ⋮            ⋮
K             │ 0.000164331   7.26384e-5      3.23411e-5  0.000132186
M             │   0.0118757    0.0059422      1.11565e-5   4.41652e-5
F             │  5.74392e-5   3.38747e-5      1.19009e-5   4.74467e-5
P             │   8.4879e-5   4.22958e-5       1.9068e-5   0.00599265
S             │ 0.000178273    0.0237501      4.54994e-5  0.000164678
T             │   0.0119875   0.00601152      3.95731e-5    0.0238011
W             │  2.31282e-5   1.06641e-5      4.26634e-6   1.51093e-5
Y             │  5.25122e-5   2.59818e-5      9.97894e-6   3.99734e-5
V             │ 0.000165007    0.0237526  …   3.89671e-5    0.0119657

marginals : 20×2 Named Array{Float64,2}
Residue ╲ Dim │       Dim_1        Dim_2
──────────────┼─────────────────────────
A             │     0.34029     0.179751
R             │   0.0605751    0.0722349
N             │ 0.000873079    0.0066301
D             │ 0.000933551   0.00069581
C             │ 0.000409106    0.0123548
Q             │    0.137259   0.00655837
E             │   0.0428809  0.000892725
G             │   0.0133216    0.0130128
H             │   0.0123657    0.0361028
⋮                         ⋮            ⋮
K             │     0.03113    0.0248551
M             │   0.0182617  0.000690462
F             │ 0.000565162    0.0127288
P             │   0.0305487     0.114134
S             │   0.0728915    0.0960991
T             │    0.143689    0.0248567
W             │  0.00612312   0.00014787
Y             │ 0.000481824  0.000532213
V             │   0.0608515    0.0907427

total : 1.0</pre><p>You can also use <code>apply_pseudofrequencies!</code> in a previously filled probability contingency table. i.e. <code>apply_pseudofrequencies!(Pij, BLOSUM_Pseudofrequencies(α, β))</code></p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>BLOSUM_Pseudofrequencies</code> can be only be applied in <strong>normalized/probability</strong> tables with <code>UngappedAlphabet</code>.  </p></div></div><h2 id="Correction-for-data-redundancy-in-a-MSA"><a class="docs-heading-anchor" href="#Correction-for-data-redundancy-in-a-MSA">Correction for data redundancy in a MSA</a><a id="Correction-for-data-redundancy-in-a-MSA-1"></a><a class="docs-heading-anchor-permalink" href="#Correction-for-data-redundancy-in-a-MSA" title="Permalink"></a></h2><p>A simple way to reduce redundancy in a MSA without losing sequences, is clusterization and sequence weighting. The weight of each sequence should be 1/N, where N is the number of sequences in its cluster. The <code>Clusters</code> type of the <code>MSA</code> module stores the weights. This vector of weights can be extracted (with the <code>getweight</code> function) and used by the <code>count</code> and <code>probabilities</code> functions with the keyword argument <code>weights</code>. Also it&#39;s possible to use the <code>Clusters</code> as second argument of the function <code>count!</code>.  </p><pre><code class="language-julia">clusters = hobohmI(msa, 62) # from MIToS.MSA</code></pre><pre class="documenter-example-output">MIToS.MSA.Clusters([85, 2, 7, 24, 39, 2, 1, 1, 2, 4  …  1, 2, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 2, 3, 4, 5, 6, 7, 8, 1  …  5, 1, 83, 1, 24, 26, 11, 1, 1, 1], [0.011764705882352941, 0.011764705882352941, 0.5, 0.14285714285714285, 0.041666666666666664, 0.02564102564102564, 0.5, 1.0, 1.0, 0.011764705882352941  …  0.02564102564102564, 0.011764705882352941, 1.0, 0.011764705882352941, 0.14285714285714285, 0.25, 0.14285714285714285, 0.011764705882352941, 0.011764705882352941, 0.011764705882352941])</pre><pre><code class="language-julia">count(msa[:,1], msa[:,2], weights=clusters)</code></pre><pre class="documenter-example-output">MIToS.Information.Counts{Float64,2,MIToS.MSA.UngappedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.UngappedAlphabet} : 

table : 20×20 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │         A          R  …          Y          V
──────────────┼──────────────────────────────────────────────
A             │   1.57143  0.0235294  …        0.0   0.805195
R             │       0.0        0.0           0.0   0.142857
N             │       0.0        0.0           0.0        0.0
D             │       0.0        0.0           0.0        0.0
C             │       0.0        0.0           0.0        0.0
Q             │   2.64286        0.0           0.0  0.0416667
E             │       0.0        0.0           0.0        0.0
G             │       1.0        0.0           0.0        0.0
H             │       1.0        0.0           0.0        0.0
⋮                       ⋮          ⋮  ⋱          ⋮          ⋮
K             │       0.0        0.0           0.0        0.0
M             │ 0.0833333        0.5           0.0        0.0
F             │       0.0        0.0           0.0        0.0
P             │       0.0        0.0           0.0   0.142857
S             │       0.0  0.0470588           0.0        0.0
T             │       1.0        0.5           0.0   0.363636
W             │       0.0        0.0           0.0        0.0
Y             │       0.0        0.0           0.0        0.0
V             │       0.0  0.0470588  …        0.0  0.0235294

marginals : 20×2 Named Array{Float64,2}
Residue ╲ Dim │     Dim_1      Dim_2
──────────────┼─────────────────────
A             │   5.83517    8.04762
R             │   2.01611    1.11765
N             │       0.0   0.333333
D             │       0.0        0.0
C             │       0.0    1.01176
Q             │   6.22619        1.0
E             │   1.54706        0.0
G             │   1.01176  0.0235294
H             │       1.0  0.0705882
⋮                       ⋮          ⋮
K             │   1.95238    1.66667
M             │  0.583333        0.0
F             │       0.0  0.0235294
P             │   2.53571    3.28403
S             │   2.43922    3.27255
T             │   3.57219   0.767857
W             │ 0.0117647        0.0
Y             │       0.0        0.0
V             │  0.117647    1.51974

total : 29.848535777947536</pre><h2 id="Estimating-information-measures-on-an-MSA"><a class="docs-heading-anchor" href="#Estimating-information-measures-on-an-MSA">Estimating information measures on an MSA</a><a id="Estimating-information-measures-on-an-MSA-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-information-measures-on-an-MSA" title="Permalink"></a></h2><p>The <code>Information</code> module has a number of functions defined to calculate information measures from <code>Counts</code> and <code>Probabilities</code>:</p><ul><li><code>entropy</code> : Shannon entropy (H)</li><li><code>marginal_entropy</code> : Shannon entropy (H) of the marginals</li><li><code>kullback_leibler</code> : Kullback-Leibler (KL) divergence</li><li><code>mutual_information</code> : Mutual Information (MI)</li><li><code>normalized_mutual_information</code> : Normalized Mutual Information (nMI) by Entropy</li><li><code>gap_intersection_percentage</code></li><li><code>gap_union_percentage</code></li></ul><p>Information measure functions take optionally the base as the last positional argument (default: <code>e</code>). You can use <code>2.0</code> to measure information in bits.</p><pre><code class="language-julia">using MIToS.Information
using MIToS.MSA

Ni = count(res&quot;PPCDPPPPPKDKKKKDDGPP&quot;) # Ni has the count table of residues in this low complexity sequence

H = entropy(Ni) # returns the Shannon entropy in nats (base e)</code></pre><pre class="documenter-example-output">1.327362863420189</pre><pre><code class="language-julia">H = entropy(Ni, 2.0) # returns the Shannon entropy in bits (base 2)</code></pre><pre class="documenter-example-output">1.9149798205164812</pre><p>Information module defines special iteration functions to easily and efficiently compute a measure over a MSA. In particular, <code>mapcolfreq!</code> and <code>mapseqfreq!</code> map a function that takes a table of <code>Counts</code> or <code>Probabilities</code>. The table is filled in place with the counts or probabilities of each column or sequence of a MSA, respectively. <code>mapcolpairfreq!</code> and <code>mapseqpairfreq!</code> are similar, but they fill the table using pairs of columns or sequences, respectively.  </p><p>This functions take three positional arguments: the function <code>f</code> to be calculated, the <code>msa</code> and <code>table</code> of <code>Counts</code> or <code>Probabilities</code>.  </p><p>After that, this function takes some keyword arguments:</p><ul><li><code>weights</code> (default: <code>NoClustering()</code>) : Weights to be used for table counting.</li><li><code>pseudocounts</code> (default: <code>NoPseudocount()</code>) : <code>Pseudocount</code> object to be applied to table.</li><li><code>pseudofrequencies</code> (default: <code>NoPseudofrequencies()</code>) : <code>Pseudofrequencies</code> to be</li></ul><p>applied to the normalized (probabilities) table.  </p><p><code>mapcolpairfreq!</code> and <code>mapseqpairfreq!</code> also have a fourth positional argument <code>usediagonal</code> that indicates if the function should be applied to identical element pairs (default to <code>Val{true}</code>). This two functions also have an extra keyword argument <code>diagonalvalue</code> (default to zero) to indicate the value used to fill the diagonal elements if <code>usediagonal</code> is <code>Val{false}</code>.  </p><h4 id="Example:-Estimating-*H(X)*-and-*H(X,-Y)*-over-an-MSA"><a class="docs-heading-anchor" href="#Example:-Estimating-*H(X)*-and-*H(X,-Y)*-over-an-MSA">Example: Estimating <em>H(X)</em> and <em>H(X, Y)</em> over an MSA</a><a id="Example:-Estimating-*H(X)*-and-*H(X,-Y)*-over-an-MSA-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Estimating-*H(X)*-and-*H(X,-Y)*-over-an-MSA" title="Permalink"></a></h4><p>In this example, we are going to use <code>mapcolfreq!</code> and <code>mapcolpairfreq!</code> to estimate Shannon <code>entropy</code> of MSA columns <em>H(X)</em> and the joint entropy <em>H(X, Y)</em> of columns pairs, respectively.  </p><pre><code class="language-julia">using MIToS.MSA

msa = read(&quot;http://pfam.xfam.org/family/PF09776/alignment/full&quot;, Stockholm)</code></pre><pre class="documenter-example-output">AnnotatedMultipleSequenceAlignment with 349 annotations : 325×116 Named Array{MIToS.MSA.Residue,2}
                 Seq ╲ Col │  36   37   38   39   40  …  180  183  184  185  186
───────────────────────────┼────────────────────────────────────────────────────
A0A2K6AF64_MANLE/10-125    │   L    L    R    Q    S  …    Q    F    W    N    R
G1RVK4_NOMLE/46-161        │   -    L    R    Q    S       Q    F    W    T    R
A0A0V0S2G9_9BILA/731-840   │   -    -    -    -    -       Y    L    W    K    K
A0A1V4KDS6_PATFA/159-270   │   -    -    -    -    -       K    F    W    K    K
M4A0G1_XIPMA/29-139        │   -    -    -    -    -       H    L    W    K    K
A0A1I8N4P6_MUSDO/6-107     │   -    -    -    -    -       K    Y    I    K    K
A0A3Q0KLM0_SCHMA/10-112    │   -    -    -    -    -       F    L    L    K    -
A0A3S0ZHC3_ELYCH/11-117    │   -    -    -    -    -       K    Y    F    K    -
E0VEI6_PEDHC/4-112         │   -    -    -    -    -       N    L    L    K    K
⋮                              ⋮    ⋮    ⋮    ⋮    ⋮  ⋱    ⋮    ⋮    ⋮    ⋮    ⋮
A0A2Y9IJF3_ENHLU/10-125    │   -    L    Q    Q    P       R    F    W    T    K
H3DW02_PRIPA/2-115         │   -    -    -    -    -       S    F    W    -    -
A0A2I3GIP3_NOMLE/10-125    │   -    L    R    Q    S       Q    F    W    T    R
A0A3B3RWX1_9TELE/15-129    │   -    -    -    -    -       K    F    W    K    K
A0A090MXF3_STRRB/2-104     │   -    -    -    -    -       K    L    W    K    -
A0A3B1JKX3_ASTMX/16-130    │   -    -    -    -    V       K    F    W    K    K
G3WPK1_SARHA/11-126        │   -    L    Q    Q    N       K    F    W    K    K
M3XPJ7_MUSPF/10-125        │   -    L    Q    Q    P       R    F    W    T    K
A0A2K6LYH7_RHIBE/10-125    │   L    L    R    Q    S  …    Q    F    W    N    R</pre><p>We are going to count residues to estimate the entropy. The <code>entropy</code> estimation is performed over a rehused <code>Counts</code> object. The result will be a vector containing the values estimated over each column without counting gaps (<code>UngappedAlphabet</code>).  </p><pre><code class="language-julia">using MIToS.Information

Hx = mapcolfreq!(entropy, msa, Counts(ContingencyTable(Float64, Val{1}, UngappedAlphabet())))</code></pre><pre class="documenter-example-output">1×116 Named Array{Float64,2}
Function ╲ Col │        36         37  …        185        186
───────────────┼──────────────────────────────────────────────
entropy        │  0.163024   0.212627  …    1.44723   0.417573</pre><p>If we want the <strong>joint entropy</strong> between columns pairs, we need to use a bidimensional table of <code>Counts</code> and <code>mapcolpairfreq!</code>.</p><pre><code class="language-julia">Hxy = mapcolpairfreq!(entropy, msa, Counts(ContingencyTable(Float64, Val{2}, UngappedAlphabet())))</code></pre><pre class="documenter-example-output">116×116 Named PairwiseListMatrices.PairwiseListMatrix{Float64,true,Array{Float64,1}}
Col1 ╲ Col2 │       36        37        38  …       184       185       186
────────────┼──────────────────────────────────────────────────────────────
36          │ 0.163024  0.324508   1.06025  …  0.165443   1.35532  0.683821
37          │ 0.324508  0.212627   1.11923     0.218364    1.4729  0.766528
38          │  1.06025   1.11923   1.11361      1.12325   2.15304   1.34936
39          │ 0.523719  0.911982   1.76609     0.822366   1.89963   1.39218
40          │  1.71107   1.83736   2.21128       2.0641   2.67849   2.14642
41          │  1.60595   1.62343   2.19468      1.73596   2.51976   1.67664
42          │  1.24538   1.32071   2.05898       1.5875     2.638   1.88945
43          │  1.37695   1.45336   2.04728      1.88216   2.74751   2.02338
45          │  1.31993    1.3887   1.98267      1.76079   2.62468   1.86244
⋮                    ⋮         ⋮         ⋮  ⋱         ⋮         ⋮         ⋮
176         │ 0.329286  0.435528   1.35976      2.25656   2.60849   1.88979
177         │  1.30677   1.40572   1.93485      2.70096   2.69006   2.15024
178         │ 0.165443  0.218364   1.12325      1.12077   1.51743  0.464759
179         │  1.24314   1.41002   2.03733      2.66918   2.87673   2.26195
180         │  0.94187  0.949305   1.79632      2.46916   2.46379   1.94449
183         │ 0.329286  0.326721   1.22236      1.71291   2.22476   1.35681
184         │ 0.165443  0.218364   1.12325      1.06704   2.22513   1.31912
185         │  1.35532    1.4729   2.15304      2.22513   1.44723   1.57342
186         │ 0.683821  0.766528   1.34936  …   1.31912   1.57342  0.417573</pre><p>In the above examples, we indicate the type of each occurrence in the counting and the probability table to use. Also, it&#39;s possible for some measures as <strong>entropy</strong> and <strong>mutual information</strong>, to estimate the values only with the count table (without calculate the probability table). Estimating measures only with a <code>ResidueCount</code> table, when this is possible, should be faster than using a probability table.  </p><pre><code class="language-julia">Time_Pab = map(1:100) do x
    time = @elapsed mapcolpairfreq!(entropy, msa, Probabilities(ContingencyTable(Float64, Val{2}, UngappedAlphabet())))
end

Time_Nab = map(1:100) do x
    time = @elapsed mapcolpairfreq!(entropy, msa, Counts(ContingencyTable(Float64, Val{2}, UngappedAlphabet())))
end

using Plots
gr()

histogram( [Time_Pab Time_Nab],
    labels = [&quot;Using ResidueProbability&quot; &quot;Using ResidueCount&quot;],
    xlabel = &quot;Execution time [seconds]&quot; )</code></pre><p><img src="../inf_entropy.png" alt/>   </p><h2 id="Corrected-Mutual-Information"><a class="docs-heading-anchor" href="#Corrected-Mutual-Information">Corrected Mutual Information</a><a id="Corrected-Mutual-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Corrected-Mutual-Information" title="Permalink"></a></h2><p>MIToS ships with two methods to easily calculate corrected mutual information.   The first is the algorithm described in <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2672635/"><em>Buslje et. al. 2009</em><img src="../assets/external-link.png" alt/></a>. This algorithm can be accessed through the <code>buslje09</code> function and includes:  </p><ol><li>Low count correction using <code>AdditiveSmoothing</code></li><li>Sequence weighting after a <code>hobohmI</code> clustering</li><li>Average Product Correction (APC) proposed by</li></ol><p><a href="http://bioinformatics.oxfordjournals.org/content/24/3/333">Dunn et. al. 2008<img src="../assets/external-link.png" alt/></a>, through the <code>APC!</code> function that takes a MI matrix.</p><ol><li>Z score correction using the functions <code>shuffle!</code> from the MSA module and <code>zscore</code></li></ol><p>from the <code>PairwiseListMatrices</code> package.  </p><article class="docstring"><header><a class="docstring-binding" id="MIToS.Information.buslje09" href="#MIToS.Information.buslje09"><code>MIToS.Information.buslje09</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>buslje09</code> takes a MSA or a file and a <code>FileFormat</code> as first arguments. It calculates a Z score and a corrected MI/MIp as described on <strong>Busjle et. al. 2009</strong>.</p><p>keyword argument, type, default value and descriptions:</p><pre><code class="language-none">  - lambda      Float64   0.05    Low count value
  - clustering  Bool      true    Sequence clustering (Hobohm I)
  - threshold             62      Percent identity threshold for clustering
  - maxgap      Float64   0.5     Maximum fraction of gaps in positions included in calculation
  - apc         Bool      true    Use APC correction (MIp)
  - samples     Int       100     Number of samples for Z-score
  - fixedgaps   Bool      true    Fix gaps positions for the random samples
  - alphabet    ResidueAlphabet UngappedAlphabet()  Residue alphabet to be used</code></pre><p>This function returns:</p><pre><code class="language-none">  - Z score
  - MI or MIp</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/diegozea/MIToS.jl/blob/60e1487f4251526f40cb906728707ee1469d2582/src/Information/CorrectedMutualInformation.jl#L19-L42">source</a></section></article><p>The second, implemented in the <code>BLMI</code> function, has the same corrections that the above algorithm, but use BLOSUM62 pseudo frequencies. This function is <strong>slower</strong> than <code>buslje09</code> (at the same number of samples), but gives <strong>better performance</strong> (for structural contact prediction) when the MSA has <strong>less than 400 clusters</strong> after a Hobohm I at 62% identity.  </p><article class="docstring"><header><a class="docstring-binding" id="MIToS.Information.BLMI" href="#MIToS.Information.BLMI"><code>MIToS.Information.BLMI</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>BLMI</code> takes a MSA or a file and a <code>FileFormat</code> as first arguments. It calculates a Z score (ZBLMI) and a corrected MI/MIp as described on <strong>Busjle et. al. 2009</strong> but using using BLOSUM62 pseudo frequencies instead of a fixed pseudocount.</p><p>Keyword argument, type, default value and descriptions:</p><pre><code class="language-none">  - beta        Float64   8.512   β for BLOSUM62 pseudo frequencies
  - lambda      Float64   0.0     Low count value
  - threshold             62      Percent identity threshold for sequence clustering (Hobohm I)
  - maxgap      Float64   0.5     Maximum fraction of gaps in positions included in calculation
  - apc         Bool      true    Use APC correction (MIp)
  - samples     Int       50      Number of samples for Z-score
  - fixedgaps   Bool      true    Fix gaps positions for the random samples</code></pre><p>This function returns:</p><pre><code class="language-none">  - Z score (ZBLMI)
  - MI or MIp using BLOSUM62 pseudo frequencies (BLMI/BLMIp)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/diegozea/MIToS.jl/blob/60e1487f4251526f40cb906728707ee1469d2582/src/Information/CorrectedMutualInformation.jl#L94-L117">source</a></section></article><h4 id="Example:-Estimating-corrected-MI-from-an-MSA"><a class="docs-heading-anchor" href="#Example:-Estimating-corrected-MI-from-an-MSA">Example: Estimating corrected MI from an MSA</a><a id="Example:-Estimating-corrected-MI-from-an-MSA-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Estimating-corrected-MI-from-an-MSA" title="Permalink"></a></h4><pre><code class="language-julia">using MIToS.MSA
using MIToS.Information

msa = read(&quot;http://pfam.xfam.org/family/PF16078/alignment/full&quot;, Stockholm)
ZMIp, MIp  = buslje09(msa)
ZMIp</code></pre><pre class="documenter-example-output">39×39 Named PairwiseListMatrices.PairwiseListMatrix{Float64,false,Array{Float64,1}}
Col1 ╲ Col2 │         14          15  …          55          56
────────────┼──────────────────────────────────────────────────
14          │        NaN   -0.174449  …    -2.70273     1.15057
15          │  -0.174449         NaN     -0.0664451     4.92855
16          │    3.34244     1.66443       -0.12868   -0.505651
17          │   0.792409    -1.89006       -1.90557   -0.554321
18          │   -1.54005    -1.34956        4.19909   -0.991399
19          │   -3.87423    0.546234      0.0735688   -0.987466
20          │    1.62265    -3.64397         2.7444     -1.0097
24          │   -5.01602    -1.82055       0.114365    -3.28149
25          │   -5.14258    -2.38415       -2.26778     -3.2884
⋮                      ⋮           ⋮  ⋱           ⋮           ⋮
48          │    -2.5951   -0.620338        1.57541    -1.94703
49          │   -2.11127     6.14127        11.3885   -0.363373
50          │    3.89966    -2.01513       -3.19587   -0.424129
51          │   -1.10728      1.6108        2.07298     0.27784
52          │   -3.20368   -0.322192        7.98528   -0.477724
53          │ -0.0397517    -3.36352        6.89771   -0.807052
54          │    -4.3909     7.95714        6.05652     3.77664
55          │   -2.70273  -0.0664451            NaN     3.72601
56          │    1.15057     4.92855  …     3.72601         NaN</pre><pre><code class="language-julia">ZBLMIp, BLMIp  = BLMI(msa)
ZBLMIp</code></pre><pre class="documenter-example-output">39×39 Named PairwiseListMatrices.PairwiseListMatrix{Float64,false,Array{Float64,1}}
Col1 ╲ Col2 │           14            15  …            55            56
────────────┼──────────────────────────────────────────────────────────
14          │          NaN    -0.0582588  …    -0.0251813    -0.0105116
15          │   -0.0582588           NaN       -0.0278714     0.0476465
16          │  -0.00601197    -0.0298699      -0.00777756    -0.0407649
17          │    0.0174541    -0.0523991       -0.0326343     0.0112349
18          │   -0.0305729    -0.0171681         0.067727   -0.00945625
19          │   -0.0352929   -0.00705144       -0.0152542    0.00916268
20          │    0.0189767    -0.0345342        0.0473955   -0.00507911
24          │   -0.0479257     -0.032168       -0.0102186     -0.047936
25          │   -0.0280285    -0.0413133       -0.0525641    -0.0335003
⋮                        ⋮             ⋮  ⋱             ⋮             ⋮
48          │  -0.00189678   -0.00546818       0.00886645     -0.011731
49          │     -0.01803     0.0959256         0.159229  -0.000594916
50          │    0.0117199   -0.00206818       0.00168347    -0.0178146
51          │   0.00604482     0.0393056        0.0274851     0.0202185
52          │   -0.0217258   -0.00501688        0.0720166   -0.00513599
53          │  -6.78417e-5    -0.0630777        0.0681189    -0.0193718
54          │   -0.0319262      0.117684        0.0503137     0.0620418
55          │   -0.0251813    -0.0278714              NaN     0.0274268
56          │   -0.0105116     0.0476465  …     0.0274268           NaN</pre><h2 id="Visualize-Mutual-Information"><a class="docs-heading-anchor" href="#Visualize-Mutual-Information">Visualize Mutual Information</a><a id="Visualize-Mutual-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Visualize-Mutual-Information" title="Permalink"></a></h2><p>You can use the function of the <code>Plots</code> package to visualize the Mutual Information (MI) network between residues. As an example, we are going to visualize the MI between residues of the Pfam domain <em>PF16078</em>. The <code>heatmap</code> is the simplest way to visualize the values of the Mutual Information matrix.  </p><pre><code class="language-julia">using Plots
gr()

heatmap(ZMIp, yflip=true)</code></pre><pre class="documenter-example-output">┌ Warning: Attribute alias `ratio` detected in the user recipe defined for the signature (::NamedArrays.NamedArray{Float64,2,PairwiseListMatrices.PairwiseListMatrix{Float64,false,Array{Float64,1}},Tuple{OrderedCollections.OrderedDict{String,Int64},OrderedCollections.OrderedDict{String,Int64}}}). To ensure expected behavior it is recommended to use the default attribute `aspect_ratio`.
└ @ Plots ~/.julia/packages/Plots/ViMfq/src/pipeline.jl:15</pre><p><img src="../inf_heatmap.png" alt/>   </p><p>ZMIp is a Z score of the corrected MIp against its distribution on a random MSA (shuffling the residues in each sequence), so pairs with highest values are more likely to co-evolve. Here, we are going to use the top 1% pairs of MSA columns.  </p><pre><code class="language-julia">using PairwiseListMatrices # to use getlist
using Statistics # to use quantile

threshold = quantile(getlist(ZMIp), 0.99)</code></pre><pre class="documenter-example-output">10.034074403378517</pre><pre><code class="language-julia">ZMIp[ ZMIp .&lt; threshold ] .= NaN
heatmap(ZMIp, yflip=true)</code></pre><pre class="documenter-example-output">┌ Warning: Attribute alias `ratio` detected in the user recipe defined for the signature (::NamedArrays.NamedArray{Float64,2,PairwiseListMatrices.PairwiseListMatrix{Float64,false,Array{Float64,1}},Tuple{OrderedCollections.OrderedDict{String,Int64},OrderedCollections.OrderedDict{String,Int64}}}). To ensure expected behavior it is recommended to use the default attribute `aspect_ratio`.
└ @ Plots ~/.julia/packages/Plots/ViMfq/src/pipeline.jl:15</pre><p><img src="../inf_heatmap_top.png" alt/>   </p><p>We are going to calculate the cMI (cumulative mutual information) value of each node. Where cMI is a mutual information score per position that characterizes the extent of mutual information &quot;interactions&quot; in its neighbourhood. This score is calculated as the sum of MI values above a certain threshold for every amino acid pair where the particular residue appears. This value defines to what degree a given amino acid takes part in a mutual information network and we are going to indicate it using the node color. To calculate cMI we are going to use the <code>cumulative</code> function:   </p><pre><code class="language-julia">cMI = cumulative(ZMIp, threshold)</code></pre><pre class="documenter-example-output">1×39 Named Array{Float64,2}
Function ╲ Col2 │      14       15       16  …       54       55       56
────────────────┼────────────────────────────────────────────────────────
cumulative      │     0.0      0.0      0.0  …  12.1623  11.3885      0.0</pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../MSA/">« MSA</a><a class="docs-footer-nextpage" href="../SIFTS/">SIFTS »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 5 August 2020 19:43">Wednesday 5 August 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
